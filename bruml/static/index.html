<!DOCTYPE html>
<!--  ruml; about 40 hours;
      
  This and the bcserver.js file demonstrate functionality (using websockets)
  desired in the open source FinalsClub "backchan.nl clone" workproduct which 
  should consist of:
    1) a javascript library to be included on the html page to be served,
    2) a node module to be required by the server, and 
    3) one or more example skins demonstrating how to integrate the library 
       and module into a working application.
      
  // messages are objects with one property whose value is the
  // type of message:
  //   { "post":        { "objtype": "post", <other Post properties> } }
  //   { "topPosts":    [ <array of Post objects> ] }
  //   { "recentPosts": [ <array of Post objects> ] }
  //   { "vote":        { "objtype": "vote", "postid": <string>, "direction": <"up"|"down"> } }
  
  When a post is voted on by this client during a browser session, its
  postid is stored in the postsVoted array.  When posts objects arrive, they are
  assigned a new property "voted" with value true or false depending on 
  whether present in the postVoted array.  After being rendered, posts which
  have not been voted are given the class "unvoted" on the postVoteContainer 
  div. An unvoted post is displayed with a colored background for the
  postVoteContainer div. {Voting should remove the class but the refresh of
  posts by the server occurs so quickly that this is unnecessary.)  The
  mechanism for detecting and preventing repeated votes is in place but
  disabled to permit a more interesting demonstration.
  
  Note that the details for the display of recent posts has not been considered
  in this demo.

  TO DO: 1. Store postsVoted in local storage at end of session (onUnload);
         2. Get number-of-votes digit placed properly within rect;
         3. On click of showpostsButton, replace button with current value
            with button for previous value;
         4. If number of posts being displayed is fewer than the total, display
            the limit before "Highest";
         5. Devise a way of selecting the school, class and lecture (i.e.,
            meeting-id) to be interacted with;
-->
<html>
<head>
  <title>FinalsClub</title>
  <link rel="shortcut icon" href="rumlfavicon.ico">
  <script src="http://code.jquery.com/jquery-1.6.min.js"></script>
  <script src="http://ajax.microsoft.com/ajax/jquery.templates/beta1/jquery.tmpl.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    var PORT = 8080;
    var currMeetingID = "888";
    var MAXPOSTS = 10;
    var posts = [];
    var sortedBy = 'votes';
    var socket;
    // note that this array applies only to this browser session!
    //  ==> could vote twice on same post during different sessions.
    // use local storage??
    var postsVoted = [];
    var userObj = { userID: null, userName: null, userAffil: null };
    // the Post object is modelled on EtherPad:
    //  [the schoolid and courseid are implied in the meetingid];
    function assembleNewPostObj(msgBody) {
      // the postid is assigned at the server;
      var postObj = { objtype: "post", postid: null,
                      posvotes: 0, negvotes: 0,
                      // these are copied from EtherPad; use is unknown;
                      isdeleted: false, ispromoted: false, isdemoted: false };
      postObj.meetingid = null;
      postObj.userid    = userObj.userID;
      postObj.username  = userObj.userName;
      postObj.useraffil = userObj.userAffil;
      postObj.created = (new Date).getTime();
      postObj.body = msgBody;
      return postObj;
    }
    function renderPosts() {
      $('#posts .postContainer').remove();
      //$('#total_posts').text(posts.length);
      // truncate long array of Posts;
      var sortedPosts = sortedBy == 'created' ? posts.sort(createdDesc) : posts.sort(votesDesc);
      var displayPosts = sortedPosts.slice(0, MAXPOSTS - 1);
      $("#postTemplate").tmpl(displayPosts).appendTo("#posts");
      $('#posts .postVoteContainer').each(function(idx, container) {
        var postid = $(container).attr("data-postid");
        if (postsVoted.indexOf(postid) != -1) {
          console.log("For " + postid + ": voted");
        } else {
          console.log("For " + postid + ": NOT voted");
          $(container).addClass("unvoted");
        }
      });    
    }

    function assembleVoteObj(postid, upOrDown) {
      return { "objtype": "vote", "postid": postid, "direction": upOrDown };
    }
    function votesDesc(a, b) {
      aRank = a.posvotes - (a.negvotes * 0.5);
      bRank = b.posvotes - (b.negvotes * 0.5);
      // for descending, reverse usual order; 
      return bRank - aRank;
    }
    function createdDesc(a, b) {
      // for descending, reverse usual order; 
      return b.created - a.created;
    }
    $(document).ready(function(){
      // fill in holes;
      //setUserNameAndAffil();
      $('#loginForm').submit(function(e) {
        e.preventDefault();
        userObj.userName = $(this).find('#userName').val();
        userObj.userAffil = $(this).find('#userAffiliation').val();
        userObj.userID = 1234;
        $('.userName').text(userObj['userName']);
        $('.userAffil').text(userObj['userAffil']);
        $(this).addClass('hidden');
        $('#userBox').removeClass('hidden');
      });
      // add event handlers;
      $('#backchatHeader input[type="button"]').click(function() {
        $('#backchatHeaderInstructions').toggle(500);
      });
      $('#enterPostTextarea').keyup(function() {
        var charLimit = 250;
        var charsUsed = $(this).val().length;
        if (charsUsed > 25) {
          $('#charsLeftMsg').text("characters left: " + 
            (charLimit - charsUsed).toString());
        } else {
          $('#charsLeftMsg').text(" ");

        }
      });
      $('#submitPost').click(function() {
        var newPost = assembleNewPostObj($('#enterPostTextarea').val());
        socket.emit('post', newPost);
        $('#enterPostTextarea').val('');
      });
      $('.vote-tally-rect').live("click", function() {
        var postid = $(this).parent().attr('data-postid');
        var direction = $(this).hasClass("vote-up") ? "up" : "down";
        console.log("NEW VOTE: PostID is " + postid + "; Direction is " + direction);
        if (postsVoted.indexOf(postid) != -1) {
          // already voted on this post;
          console.log("You already voted on this post!");
          // allow for now;
          // eventually: show dialog for 2 seconds; return;
        }
        // unnecessary: $(this).parent().removeClass("unvoted");
        postsVoted.push(postid);
        var newVoteObj = assembleVoteObj(postid, direction);
        socket.emit('vote', newVoteObj);
      });
      $('#amountPosts').change(function() {
        MAXPOSTS = $(this).val();
        renderPosts();
      });
      $('#sortPosts').change(function() {
        var sort = $(this).val();
        sortedBy = sortedBy !== sort ? sort : sortedBy;
        renderPosts();
      });
      //=====================================================================
      // create socket to server; note that we only permit websocket transport
      // for this demo;
      var loc = document.location;
      var port = loc.port == '' ? (loc.protocol == 'https:' ? 443 : 80) : loc.port;
      var url = loc.protocol + '//' + loc.hostname + ':' + port;
      socket = io.connect(url);
      // incoming messages are objects with one property whose value is the
      // type of message:
      //   { "posts":    [ <array of Post objects> ] }
      //   { "recentPosts": [ <array of Post objects> ] }
      //   { "vote":        [ "postid": <string>, "direction": <"up"|"down"> ] }
      // Unresolved: whether to send vote messages for local change of display
      // or new arrays of posts with updated vote counts.  Vote message would not
      // be adequate if it changed order of posts.  For now, send two new
      // arrays with updated vote counts and refrain from sending vote message.
      var messagesArrived = 0;
      socket.on('connect', function(){
        var hash = window.location.hash.substring(1);
        socket.emit('lectureID', hash);
        $(window).bind('hashchange', function() {
          var hash = window.location.hash.substring(1);
          socket.emit('lectureID', hash);
        });
      });
       socket.on('message', function(obj) {
          if ('posts' in obj) {
            posts = obj.posts;
            renderPosts();
          }
        });
        socket.on('posts', function(posts) {
          console.log(posts);
        })
        socket.on('post', function(post) {
          posts.push(post);
          renderPosts();
        });
        socket.on('vote', function(vote) {
          posts = posts.map(function(post) {
            if(post.postid == vote.postid) {
              switch (vote.direction) {
                case 'up': 
                  post.posvotes++;
                  break;
                case 'down':
                  post.negvotes++;
                  break;
              }
            }
            return post;
          });
          console.log(posts)
          renderPosts();
        })

      socket.on('disconnect', function(){ 
        $('#debugDisplay').append('<p>SOCKET disconnected!</p>');
      });
      // =============>  NB!! <==============

      $('#enterPostTextarea').val("");
    });
  </script>

	<link href="general.css" rel="stylesheet">
</head>

<body>
<div id="container">
<div id="notesContainer" class="hidden">
  <div id="notesHeader">
    <div class="courseTitle">The Human Mind</div>
    <div class="lectureDesc">Lecture #6: April 3, 2001: Evolution</div>
  </div>
  <div id="notesComponent">EtherPad component goes here!</div>

  <!-- temporary -->
  <div id="debugDisplay"
       style="margin-top: 4em; 
              padding: 0.8em; 
              border: 2px solid #ddd; 
              text-align: center;">
    <input type="button" id="replaceposts" value="Replace Top Posts" />
  </div>

</div><!-- notesContainer -->

<div id="backchat">
<!-- div id="backchatHeader">
  Share your reactions:&nbsp;&nbsp;
  <input type="button" value="show instructions" />
</div>

<div id="backchatHeaderInstructions">
  <p>Use this section to react to the lecture: your posts will be seen by others <strong>immediately</strong>, and they can <strong>respond</strong> or <strong>vote your post up or down</strong>. Your post can be a <strong>question</strong>, <strong>comment</strong>, <strong>link to something related to the lecture</strong>, or whatever else you think other people might be interested in.</p>
  <p>Even if you don't have anything to say, you can <strong>vote posts up or down</strong> that you think are useful or problematic. Highly ranked and comments will be brought to the lecturer's attention.</p>
</div -->

<div id="loginBox">
  <form id="loginForm">
    <label for="name">Name:</label>
    <input type="text" id="userName" name="userName" value="" size="20" /><br>
    <label for="affiliation">Affiliation:</label>
    <input type="text" id="userAffiliation" name="userAffiliation" value="" size="20" /><br>
    <input type="submit" name="submit" value="Login" />
  </form>
</div>

<div id="userBox" class="hidden">
  <div id="userHeader">
    <span class="userName"></span>
    <span class="userAffil"></span>
    <div id="userButtons">
    	<!--
      <input type="button" id="editUser" value="Edit User" />
      <input type="button" id="adminPassword" value="Admin" />
      	-->
    </div>
  </div>

  <div id="enterUser">
    <div class="hd">Who are you?</div>
    <div class="bd">
      <form id="userAddForm" method="POST" action="/users/add">
        <table>
          <tr>
            <td><label for="name">Name:</label></td>
            <td>
                        <input type="text" id="UserName"
                            name="data[User][name]" value=""
                            maxlength="28" size="20" />
            </td>
          </tr>
          <tr>
            <td><label for="affiliation">Affiliation:</label></td>
            <td>
                <input type="text" id="UserAffiliation"
                    name="data[User][affiliation]" value=""
                    maxlength="48" size="20" />
            </td>
          </tr>
        </table>
      </form>
    </div>
  </div><!-- enterUser -->

  <div id="enterPost">
    <form id="enterPostForm">
      <!-- onkeyup for cut or copy&paste, onkeypress for hold key down -->
      <textarea id="enterPostTextarea" name="data[Post][body]"></textarea>
      <div id="charsLeftMsg">&nbsp;</div>
      <input type="hidden" id="hostMeetingId"
              name="data[Post][meeting_id]"
              value="926" />
      <input type="button" id="submitPost"
             name="submitPost" value="Post Comment" />
    </form>
  </div><!-- enterPost -->

</div><!-- userBox -->

<div id="posts">
  <div id="postsHeader">
    <span class="postsHeaderTitle">Posts</span>
    <select id="sortPosts">
      <option value="votes">Sort by votes</option>
      <option value="created">Sort by date/time</option>
    </select>
    <!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    show:
    <select id="amountPosts">
      <option value="10">10</option>
      <option value="15">15</option>
      <option value="20">20</option>
    </select>
	-->
  </div>
  
  
</div>
</div> <!-- backchat -->
</div> <!-- container -->
<!-- these templates are used to generate Top Posts from an array received from
     the server. The unknown mime type causes the browser to ignore it -->
<script id="postTemplate" type="text/x-jQuery-tmpl">
  <div class="postContainer" data-postid="${postid}">
    <div class="postVoteContainer" data-postid="${postid}">
      <div class="vote-tally-rect vote-up">${posvotes}</div>
      <div class="vote-tally-rect vote-dn">${negvotes}</div>
    </div>
    <div class="postDisplayContainer">
      <div class="postBody">${body}</div> 
      <div class="postFooter">
        <span class="userName">${username}</span>
	&mdash;
        <span class="userAffil">${useraffil}</span>
        <span class="postid">${postid}</span>
      </div> 
    </div>
  </div>
</script>
</body>
</html>
